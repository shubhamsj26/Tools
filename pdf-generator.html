<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Creator Tool - Generate from Multiple Files, Images, Text</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom scrollbar for text area */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb {
            background: rgba(147, 197, 253, 0.5); /* blue-300 with opacity */
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: rgba(147, 197, 253, 0.7);
        }

        /* Custom styles for accessibility focus */
        *:focus-visible {
            outline: 2px solid #60A5FA; /* blue-400 */
            outline-offset: 2px;
            border-radius: 0.25rem; /* Match Tailwind's default rounded-md */
        }

        /* Drag and Drop styles */
        .drag-area {
            border: 2px dashed rgba(255, 255, 255, 0.4);
            background-color: rgba(255, 255, 255, 0.05);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .drag-area.drag-over {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: #60A5FA; /* blue-400 */
        }

        /* Draggable item styles */
        .page-item {
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .page-item:active {
            cursor: grabbing;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            transform: scale(1.02);
        }
        .page-item.dragging {
            opacity: 0.5;
            border: 2px dashed #60A5FA;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-700 to-purple-900 text-gray-100 flex flex-col items-center p-4">

    <!-- Main Container -->
    <div class="bg-white bg-opacity-10 backdrop-blur-lg rounded-xl shadow-2xl p-6 md:p-8 max-w-4xl w-full border border-white border-opacity-20">
        <h1 class="text-4xl md:text-5xl font-extrabold text-center mb-6 text-white drop-shadow-lg">
            Advanced PDF Creator
        </h1>
        <p class="text-center text-gray-200 mb-8 text-lg">Generate PDFs from multiple images, text, and customize every detail.</p>

        <!-- Loading Indicator & Progress Bar -->
        <div id="loading-indicator" class="hidden flex flex-col items-center p-4 bg-blue-600 bg-opacity-80 rounded-lg mb-6 text-white font-semibold">
            <div class="flex items-center mb-2">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="loading-text">Processing files...</span>
            </div>
            <div class="w-full bg-blue-200 rounded-full h-2.5">
                <div id="progress-bar" class="bg-blue-800 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>

        <!-- Error Message Display -->
        <div id="error-message-container" class="hidden bg-red-500 bg-opacity-20 border border-red-400 text-red-200 p-4 rounded-lg mb-6 text-center">
            <p class="font-semibold">Error:</p>
            <p id="error-message-text"></p>
        </div>

        <!-- File Upload Section -->
        <div class="mb-6">
            <label for="file-upload" class="block text-lg font-semibold mb-2 text-white text-opacity-90">
                1. Upload Files (Max 50 files - JPG, PNG, GIF, TXT):
            </label>
            <div id="drop-area" class="drag-area p-6 rounded-lg text-center cursor-pointer hover:border-blue-400 transition duration-200">
                <input type="file" id="file-upload" multiple accept="image/png, image/jpeg, image/gif, text/plain" class="hidden">
                <p class="text-gray-300 text-lg mb-2"><i class="fas fa-cloud-upload-alt text-3xl mb-2"></i></p>
                <p class="text-gray-300 text-lg mb-2">Drag & Drop files here, or <span class="text-blue-400 font-bold underline">Click to Browse</span></p>
                <p class="text-sm text-gray-400">Supported: Images (JPG, PNG, GIF), Text (.TXT)</p>
                <p class="text-sm text-red-300 mt-2">Note: DOCX/PPTX/XLSX conversion is not supported client-side.</p>
            </div>
        </div>

        <!-- Uploaded Files List & Reordering -->
        <div id="uploaded-files-container" class="mt-6 mb-8 hidden">
            <h3 class="text-2xl font-bold mb-4 text-white drop-shadow-md">
                2. Arrange Pages & Edit
            </h3>
            <div id="uploaded-files-list" class="space-y-4 bg-white bg-opacity-5 p-4 rounded-lg border border-white border-opacity-10">
                <!-- Uploaded files will be listed here -->
            </div>
        </div>

        <!-- PDF Settings Section -->
        <div class="mt-8 p-6 bg-white bg-opacity-10 rounded-xl shadow-inner border border-white border-opacity-20">
            <h3 class="text-2xl font-bold mb-4 text-white drop-shadow-md">PDF Settings & Customization</h3>

            <!-- Page Size & Orientation -->
            <div class="mb-6">
                <h4 class="text-xl font-semibold mb-3 text-blue-300">Page Layout</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="page-size" class="block text-sm font-medium text-gray-300 mb-1">Page Size:</label>
                        <select id="page-size"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400 cursor-pointer">
                            <option value="A4" class="bg-gray-800">A4 (210 x 297 mm)</option>
                            <option value="Letter" class="bg-gray-800">Letter (8.5 x 11 in)</option>
                            <option value="Legal" class="bg-gray-800">Legal (8.5 x 14 in)</option>
                        </select>
                    </div>
                    <div>
                        <label for="page-orientation" class="block text-sm font-medium text-gray-300 mb-1">Orientation:</label>
                        <select id="page-orientation"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400 cursor-pointer">
                            <option value="portrait" class="bg-gray-800">Portrait</option>
                            <option value="landscape" class="bg-gray-800">Landscape</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Text Overlay -->
            <div class="mb-6">
                <h4 class="text-xl font-semibold mb-3 text-blue-300">Text Overlay (Per Page)</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="md:col-span-2">
                        <label for="overlay-text" class="block text-sm font-medium text-gray-300 mb-1">Overlay Text:</label>
                        <input type="text" id="overlay-text" placeholder="Text to appear on each page"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div>
                        <label for="overlay-font-size" class="block text-sm font-medium text-gray-300 mb-1">Font Size:</label>
                        <input type="number" id="overlay-font-size" value="24" min="8" max="100"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div>
                        <label for="overlay-x-pos" class="block text-sm font-medium text-gray-300 mb-1">X Position (from left):</label>
                        <input type="number" id="overlay-x-pos" value="50"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div>
                        <label for="overlay-y-pos" class="block text-sm font-medium text-gray-300 mb-1">Y Position (from bottom):</label>
                        <input type="number" id="overlay-y-pos" value="50"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div>
                        <label for="overlay-color" class="block text-sm font-medium text-gray-300 mb-1">Text Color:</label>
                        <input type="color" id="overlay-color" value="#FFFFFF"
                            class="w-full h-10 p-1 rounded-lg bg-white bg-opacity-20 border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400 cursor-pointer">
                    </div>
                </div>
            </div>

            <!-- Meta Tags -->
            <div class="mb-6">
                <h4 class="text-xl font-semibold mb-3 text-blue-300">Meta Tags</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="pdf-title" class="block text-sm font-medium text-gray-300 mb-1">Title:</label>
                        <input type="text" id="pdf-title" placeholder="Document Title"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div>
                        <label for="pdf-author" class="block text-sm font-medium text-gray-300 mb-1">Author:</label>
                        <input type="text" id="pdf-author" placeholder="Document Author"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="md:col-span-2">
                        <label for="pdf-keywords" class="block text-sm font-medium text-gray-300 mb-1">Keywords (comma-separated):</label>
                        <input type="text" id="pdf-keywords" placeholder="keywords, separated, by, comma"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                </div>
            </div>

            <!-- PDF Version & Encryption -->
            <div class="mb-6">
                <h4 class="text-xl font-semibold mb-3 text-blue-300">Version & Security</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="pdf-version" class="block text-sm font-medium text-gray-300 mb-1">PDF Version:</label>
                        <select id="pdf-version"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400 cursor-pointer">
                            <option value="1.7" class="bg-gray-800">1.7 (Default)</option>
                            <option value="1.4" class="bg-gray-800">1.4</option>
                            <option value="1.5" class="bg-gray-800">1.5</option>
                            <option value="1.6" class="bg-gray-800">1.6</option>
                        </select>
                    </div>
                    <div>
                        <label for="encryption-password" class="block text-sm font-medium text-gray-300 mb-1">Encryption Password (Optional):</label>
                        <input type="password" id="encryption-password" placeholder="Leave blank for no encryption"
                            class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                </div>
            </div>

            <!-- Customization: Watermark, Header, Footer -->
            <div>
                <h4 class="text-xl font-semibold mb-3 text-blue-300">Page Customization</h4>
                <div class="mb-4">
                    <label for="watermark-text" class="block text-sm font-medium text-gray-300 mb-1">Watermark Text (Optional):</label>
                    <input type="text" id="watermark-text" placeholder="e.g., DRAFT, CONFIDENTIAL"
                        class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>
                <div class="mb-4">
                    <label for="header-text" class="block text-sm font-medium text-gray-300 mb-1">Header Text (Optional):</label>
                    <input type="text" id="header-text" placeholder="e.g., Company Name, Document Title"
                        class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                </div>
                <div>
                    <label for="footer-text" class="block text-sm font-medium text-gray-300 mb-1">Footer Text (Optional):</label>
                    <input type="text" id="footer-text" placeholder="e.g., Page [pageNumber] of [pageCount]"
                        class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    <p class="text-xs text-gray-400 mt-1">Use `[pageNumber]` and `[pageCount]` for dynamic page numbering.</p>
                </div>
            </div>
        </div>

        <!-- Generate PDF Button -->
        <div class="mt-8 text-center">
            <button id="generate-pdf-button"
                class="w-full md:w-auto px-8 py-3 rounded-full text-lg font-bold
                       bg-green-500 hover:bg-green-600 text-white shadow-lg
                       transition duration-300 ease-in-out transform hover:scale-105
                       focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75"
                disabled>
                <i class="fas fa-file-export mr-2"></i> Generate PDF
            </button>
        </div>

        <!-- Download Link -->
        <div id="download-section" class="mt-8 text-center hidden">
            <h3 class="text-2xl font-bold mb-4 text-white drop-shadow-md">Download Your PDF</h3>
            <a id="download-pdf-link" href="#" download="generated-document.pdf"
                class="inline-block px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-full shadow-lg
                       transition duration-300 ease-in-out transform hover:scale-105
                       focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                <i class="fas fa-download mr-2"></i> Download PDF
            </a>
        </div>

    </div>

    <!-- Hidden Canvas for Image Processing (for rotation) -->
    <canvas id="hidden-canvas" class="hidden"></canvas>

    <!-- pdf-lib CDN -->
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.0.1/dist/fontkit.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

    <script>
        // Destructure necessary modules from pdf-lib
        const { PDFDocument, rgb, StandardFonts, PDFName, PDFString, PDFArray, PDFDict, PageSizes } = PDFLib;

        // --- DOM Element References ---
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingText = document.getElementById('loading-text');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageContainer = document.getElementById('error-message-container');
        const errorMessageText = document.getElementById('error-message-text');

        const dropArea = document.getElementById('drop-area');
        const fileUploadInput = document.getElementById('file-upload');
        const uploadedFilesContainer = document.getElementById('uploaded-files-container');
        const uploadedFilesList = document.getElementById('uploaded-files-list');

        const pageSizeSelect = document.getElementById('page-size');
        const pageOrientationSelect = document.getElementById('page-orientation');

        const overlayTextInput = document.getElementById('overlay-text');
        const overlayFontSizeInput = document.getElementById('overlay-font-size');
        const overlayXPosInput = document.getElementById('overlay-x-pos');
        const overlayYPosInput = document.getElementById('overlay-y-pos');
        const overlayColorInput = document.getElementById('overlay-color');

        const pdfTitleInput = document.getElementById('pdf-title');
        const pdfAuthorInput = document.getElementById('pdf-author');
        const pdfKeywordsInput = document.getElementById('pdf-keywords');
        const pdfVersionSelect = document.getElementById('pdf-version');
        const encryptionPasswordInput = document.getElementById('encryption-password');

        const watermarkTextInput = document.getElementById('watermark-text');
        const headerTextInput = document.getElementById('header-text');
        const footerTextInput = document.getElementById('footer-text');

        const generatePdfButton = document.getElementById('generate-pdf-button');
        const downloadSection = document.getElementById('download-section');
        const downloadPdfLink = document.getElementById('download-pdf-link');

        const hiddenCanvas = document.getElementById('hidden-canvas');
        const hiddenCtx = hiddenCanvas.getContext('2d');

        // --- Global State Variables ---
        // Array to store uploaded files, their data, and properties
        let uploadedFiles = []; // { id: string, file: File, dataUrl: string, type: string, rotation: number, element: HTMLElement }
        const MAX_FILES = 50;
        let dragSrcEl = null; // For drag-and-drop reordering

        // --- Utility Functions ---

        /**
         * Displays a message in the error container.
         * @param {string} message The error message to display.
         */
        function displayError(message) {
            errorMessageText.textContent = message;
            errorMessageContainer.classList.remove('hidden');
        }

        /**
         * Clears any displayed error messages.
         */
        function clearError() {
            errorMessageText.textContent = '';
            errorMessageContainer.classList.add('hidden');
        }

        /**
         * Shows the loading indicator and disables the generate button.
         * @param {string} text The text to display in the loading indicator.
         */
        function showLoading(text = 'Processing files...') {
            loadingText.textContent = text;
            progressBar.style.width = '0%';
            loadingIndicator.classList.remove('hidden');
            generatePdfButton.disabled = true;
            generatePdfButton.classList.add('opacity-50', 'cursor-not-allowed');
            downloadSection.classList.add('hidden'); // Hide download link during generation
            clearError(); // Clear any previous errors
        }

        /**
         * Hides the loading indicator and enables the generate button.
         */
        function hideLoading() {
            loadingIndicator.classList.add('hidden');
            generatePdfButton.disabled = uploadedFiles.length === 0; // Enable only if files are present
            generatePdfButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        /**
         * Updates the progress bar.
         * @param {number} percentage The progress percentage (0-100).
         * @param {string} text Optional text to update the loading message.
         */
        function updateProgress(percentage, text = loadingText.textContent) {
            progressBar.style.width = `${percentage}%`;
            loadingText.textContent = text;
        }

        /**
         * Hides an HTML element by adding the 'hidden' class.
         * @param {HTMLElement} element The element to hide.
         */
        function hideElement(element) {
            element.classList.add('hidden');
        }

        /**
         * Shows an HTML element by removing the 'hidden' class.
         * @param {HTMLElement} element The element to show.
         */
        function showElement(element) {
            element.classList.remove('hidden');
        }

        /**
         * Converts a color hex string (e.g., "#RRGGBB") to an rgb object for pdf-lib.
         * @param {string} hex The hex color string.
         * @returns {object} An rgb object { red, green, blue }.
         */
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return rgb(r, g, b);
        }

        // --- File Handling and UI Management ---

        /**
         * Processes uploaded files and adds them to the list.
         * @param {FileList} files The FileList object from an input or drop event.
         */
        async function handleFiles(files) {
            clearError();
            hideElement(downloadSection);

            if (uploadedFiles.length + files.length > MAX_FILES) {
                displayError(`You can upload a maximum of ${MAX_FILES} files. Please remove some or upload fewer files.`);
                return;
            }

            for (let i = 0; i < files.length; i++) {
                const file = files[i];

                // Skip unsupported file types
                if (!['image/png', 'image/jpeg', 'image/gif', 'text/plain'].includes(file.type)) {
                    displayError(`Unsupported file type: ${file.name}. Only JPG, PNG, GIF, and TXT are supported.`);
                    continue;
                }

                // Check for duplicate files (simple check by name and size)
                if (uploadedFiles.some(f => f.file.name === file.name && f.file.size === file.size)) {
                    console.warn(`Skipping duplicate file: ${file.name}`);
                    continue;
                }

                showLoading(`Reading file ${i + 1} of ${files.length}...`);
                updateProgress((i / files.length) * 100);

                try {
                    const dataUrl = await readFileAsDataURL(file);
                    const id = `file-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

                    const fileEntry = {
                        id: id,
                        file: file,
                        dataUrl: dataUrl,
                        type: file.type,
                        rotation: 0, // Default rotation
                        element: null // Will store the DOM element
                    };
                    uploadedFiles.push(fileEntry);
                    addFileToList(fileEntry);

                } catch (error) {
                    displayError(`Failed to read file ${file.name}: ${error.message}`);
                    console.error(`File read error for ${file.name}:`, error);
                }
            }
            updateProgress(100, 'All files read.');
            hideLoading();
            if (uploadedFiles.length > 0) {
                showElement(uploadedFilesContainer);
            }
        }

        /**
         * Reads a File object as a Data URL.
         * @param {File} file The File object to read.
         * @returns {Promise<string>} A promise that resolves with the Data URL.
         */
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsDataURL(file);
            });
        }

        /**
         * Adds a file entry to the uploaded files list in the UI.
         * @param {object} fileEntry The file entry object.
         */
        function addFileToList(fileEntry) {
            const itemDiv = document.createElement('div');
            itemDiv.id = fileEntry.id;
            itemDiv.draggable = true;
            itemDiv.classList.add('page-item', 'flex', 'items-center', 'justify-between', 'p-3', 'bg-white', 'bg-opacity-10', 'rounded-lg', 'border', 'border-white', 'border-opacity-20', 'shadow-sm', 'text-gray-200');

            let previewContent;
            if (fileEntry.type.startsWith('image/')) {
                previewContent = `<img src="${fileEntry.dataUrl}" alt="Preview of ${fileEntry.file.name}" class="w-16 h-16 object-cover rounded-md mr-4 border border-white border-opacity-30" style="transform: rotate(${fileEntry.rotation}deg);">`;
            } else if (fileEntry.type === 'text/plain') {
                previewContent = `<i class="fas fa-file-alt text-4xl text-blue-300 mr-4"></i>`;
            } else {
                previewContent = `<i class="fas fa-file text-4xl text-gray-300 mr-4"></i>`;
            }

            itemDiv.innerHTML = `
                <div class="flex items-center flex-grow">
                    <i class="fas fa-grip-vertical text-gray-400 mr-3 cursor-grab handle"></i>
                    ${previewContent}
                    <span class="flex-grow truncate text-sm md:text-base">${fileEntry.file.name}</span>
                </div>
                <div class="flex items-center space-x-2 ml-4">
                    ${fileEntry.type.startsWith('image/') ? `
                    <button class="rotate-btn p-2 rounded-full bg-blue-500 hover:bg-blue-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-400" title="Rotate Image">
                        <i class="fas fa-sync-alt text-white text-sm"></i>
                    </button>
                    ` : ''}
                    <button class="remove-btn p-2 rounded-full bg-red-500 hover:bg-red-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-red-400" title="Remove File">
                        <i class="fas fa-trash-alt text-white text-sm"></i>
                    </button>
                </div>
            `;

            fileEntry.element = itemDiv; // Store reference to the DOM element
            uploadedFilesList.appendChild(itemDiv);

            // Add event listeners for buttons
            const removeBtn = itemDiv.querySelector('.remove-btn');
            if (removeBtn) {
                removeBtn.addEventListener('click', () => removeFile(fileEntry.id));
            }
            const rotateBtn = itemDiv.querySelector('.rotate-btn');
            if (rotateBtn) {
                rotateBtn.addEventListener('click', () => rotateImage(fileEntry.id));
            }

            // Add drag and drop listeners
            itemDiv.addEventListener('dragstart', handleDragStart);
            itemDiv.addEventListener('dragover', handleDragOver);
            itemDiv.addEventListener('dragleave', handleDragLeave);
            itemDiv.addEventListener('drop', handleDrop);
            itemDiv.addEventListener('dragend', handleDragEnd);

            generatePdfButton.disabled = false; // Enable generate button
        }

        /**
         * Removes a file from the uploaded list and UI.
         * @param {string} id The ID of the file entry to remove.
         */
        function removeFile(id) {
            uploadedFiles = uploadedFiles.filter(entry => entry.id !== id);
            const itemToRemove = document.getElementById(id);
            if (itemToRemove) {
                itemToRemove.remove();
            }
            if (uploadedFiles.length === 0) {
                hideElement(uploadedFilesContainer);
                generatePdfButton.disabled = true; // Disable if no files
            }
            hideElement(downloadSection); // Hide download link on file removal
            clearError();
        }

        /**
         * Rotates an image file entry by 90 degrees clockwise.
         * Updates the rotation state and preview.
         * @param {string} id The ID of the image file entry to rotate.
         */
        async function rotateImage(id) {
            const fileEntry = uploadedFiles.find(entry => entry.id === id);
            if (!fileEntry || !fileEntry.type.startsWith('image/')) return;

            fileEntry.rotation = (fileEntry.rotation + 90) % 360; // Rotate by 90 degrees

            // Update the preview image rotation
            const imgElement = fileEntry.element.querySelector('img');
            if (imgElement) {
                imgElement.style.transform = `rotate(${fileEntry.rotation}deg)`;
            }
            hideElement(downloadSection); // Hide download link on edit
            clearError();
        }

        // --- Drag and Drop Reordering Logic ---
        function handleDragStart(e) {
            dragSrcEl = this; // 'this' refers to the element being dragged
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.id); // Set data to transfer (element ID)
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow drop
            e.dataTransfer.dropEffect = 'move';
            if (this !== dragSrcEl && this.classList.contains('page-item')) {
                // Add a visual indicator for where the item will be dropped
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave() {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');

            if (dragSrcEl !== this) {
                const draggedId = e.dataTransfer.getData('text/plain');
                const draggedElement = document.getElementById(draggedId);
                const dropTargetElement = this;

                // Find indices in the uploadedFiles array
                const draggedIndex = uploadedFiles.findIndex(f => f.id === draggedId);
                const dropTargetIndex = uploadedFiles.findIndex(f => f.id === dropTargetElement.id);

                if (draggedIndex > -1 && dropTargetIndex > -1) {
                    // Reorder the array
                    const [removed] = uploadedFiles.splice(draggedIndex, 1);
                    uploadedFiles.splice(dropTargetIndex, 0, removed);

                    // Reorder DOM elements
                    if (draggedIndex < dropTargetIndex) {
                        dropTargetElement.parentNode.insertBefore(draggedElement, dropTargetElement.nextSibling);
                    } else {
                        dropTargetElement.parentNode.insertBefore(draggedElement, dropTargetElement);
                    }
                }
            }
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            // Remove drag-over class from all elements
            document.querySelectorAll('.page-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            dragSrcEl = null;
        }

        // --- Main PDF Generation Function ---

        /**
         * Generates the PDF document based on user inputs and settings.
         */
        async function generatePdf() {
            showLoading('Starting PDF generation...');

            try {
                // Determine page size and orientation
                const pageSize = PageSizes[pageSizeSelect.value];
                let pageWidth = pageSize[0];
                let pageHeight = pageSize[1];

                if (pageOrientationSelect.value === 'landscape') {
                    [pageWidth, pageHeight] = [pageHeight, pageWidth]; // Swap width and height for landscape
                }

                // Create a new PDF document
                const pdfDoc = await PDFDocument.create();
                pdfDoc.registerFontkit(fontkit);

                // Set PDF Meta Tags
                pdfDoc.setTitle(pdfTitleInput.value || 'Generated Document');
                pdfDoc.setAuthor(pdfAuthorInput.value || 'PDF Creator Tool');
                pdfDoc.setKeywords((pdfKeywordsInput.value || 'pdf, generator, tool, online').split(',').map(k => k.trim()));
                pdfDoc.setProducer('Online PDF Creator Tool');
                pdfDoc.setCreator('Online PDF Creator Tool');

                // Set PDF Version
                const pdfVersion = parseFloat(pdfVersionSelect.value);
                pdfDoc.setVersion(pdfVersion);

                // Embed standard fonts
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
                const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
                const italicFont = await pdfDoc.embedFont(StandardFonts.HelveticaOblique);

                const pageMargin = 50; // Margin from edges

                // Iterate through uploaded files in their current order
                for (let i = 0; i < uploadedFiles.length; i++) {
                    const fileEntry = uploadedFiles[i];
                    updateProgress(((i / uploadedFiles.length) * 100) * 0.5, `Adding page ${i + 1} of ${uploadedFiles.length}...`); // 50% for content adding

                    const page = pdfDoc.addPage([pageWidth, pageHeight]);
                    const contentWidth = page.getWidth() - 2 * pageMargin;
                    const contentHeight = page.getHeight() - 2 * pageMargin;

                    // --- Add Content Based on File Type ---
                    if (fileEntry.type.startsWith('image/')) {
                        let image;
                        let imageBytes;

                        // Re-draw image on a hidden canvas to apply rotation before embedding
                        const img = new Image();
                        img.src = fileEntry.dataUrl;
                        await new Promise(resolve => img.onload = resolve);

                        hiddenCanvas.width = img.width;
                        hiddenCanvas.height = img.height;
                        hiddenCtx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                        // Apply rotation
                        if (fileEntry.rotation !== 0) {
                            hiddenCtx.save();
                            hiddenCtx.translate(hiddenCanvas.width / 2, hiddenCanvas.height / 2);
                            hiddenCtx.rotate(fileEntry.rotation * Math.PI / 180);
                            hiddenCtx.drawImage(img, -img.width / 2, -img.height / 2);
                            hiddenCtx.restore();
                        } else {
                            hiddenCtx.drawImage(img, 0, 0);
                        }

                        // Get image data from canvas
                        const processedDataUrl = hiddenCanvas.toDataURL(fileEntry.type === 'image/gif' ? 'image/png' : fileEntry.type); // Convert GIF to PNG for static embed
                        imageBytes = await fetch(processedDataUrl).then(res => res.arrayBuffer());

                        // Embed image based on type
                        if (fileEntry.type === 'image/png' || fileEntry.type === 'image/gif') {
                            image = await pdfDoc.embedPng(imageBytes);
                        } else if (fileEntry.type === 'image/jpeg') {
                            image = await pdfDoc.embedJpg(imageBytes);
                        }

                        // Scale image to fit page, maintaining aspect ratio
                        const imageRatio = image.width / image.height;
                        let finalImageWidth = contentWidth;
                        let finalImageHeight = contentWidth / imageRatio;

                        if (finalImageHeight > contentHeight) {
                            finalImageHeight = contentHeight;
                            finalImageWidth = contentHeight * imageRatio;
                        }

                        // Center image on the page
                        const x = pageMargin + (contentWidth - finalImageWidth) / 2;
                        const y = pageMargin + (contentHeight - finalImageHeight) / 2;

                        page.drawImage(image, {
                            x: x,
                            y: y,
                            width: finalImageWidth,
                            height: finalImageHeight,
                        });

                    } else if (fileEntry.type === 'text/plain') {
                        const textContent = await fileEntry.file.text(); // Read text file content
                        const fontSize = 12;
                        const lineHeight = fontSize * 1.5;
                        const textColor = rgb(0.9, 0.9, 0.9); // Light gray for text

                        const words = textContent.split(' ');
                        let currentLine = '';
                        let yPos = page.getHeight() - pageMargin; // Start from top margin

                        for (let j = 0; j < words.length; j++) {
                            const word = words[j];
                            const testLine = currentLine === '' ? word : `${currentLine} ${word}`;
                            const textWidth = font.widthOfTextAtSize(testLine, fontSize);

                            if (textWidth < contentWidth) {
                                currentLine = testLine;
                            } else {
                                if (yPos < pageMargin + lineHeight) { // Check if new page is needed
                                    page.drawText(currentLine, { x: pageMargin, y: yPos, font, size: fontSize, color: textColor });
                                    page = pdfDoc.addPage([pageWidth, pageHeight]); // Add new page
                                    yPos = page.getHeight() - pageMargin;
                                    // Redraw header/footer, watermark, and text overlay on new page
                                    await drawHeaderFooter(page, pdfDoc.getPages().length, uploadedFiles.length, boldFont, pageMargin, contentWidth);
                                    await drawWatermark(page, watermarkTextInput.value, boldFont);
                                    await drawTextOverlay(page, font);
                                }
                                page.drawText(currentLine, { x: pageMargin, y: yPos, font, size: fontSize, color: textColor });
                                yPos -= lineHeight;
                                currentLine = word;
                            }
                        }
                        if (currentLine !== '') { // Draw any remaining text
                            if (yPos < pageMargin + lineHeight) {
                                page = pdfDoc.addPage([pageWidth, pageHeight]);
                                yPos = page.getHeight() - pageMargin;
                                await drawHeaderFooter(page, pdfDoc.getPages().length, uploadedFiles.length, boldFont, pageMargin, contentWidth);
                                await drawWatermark(page, watermarkTextInput.value, boldFont);
                                await drawTextOverlay(page, font);
                            }
                            page.drawText(currentLine, { x: pageMargin, y: yPos, font, size: fontSize, color: textColor });
                        }
                    }
                    // Add text overlay, header, footer, watermark after content is drawn for each page
                    // This ensures they are on top of content and on every page.
                    await drawTextOverlay(page, font);
                    await drawHeaderFooter(page, i + 1, uploadedFiles.length, boldFont, pageMargin, contentWidth);
                    await drawWatermark(page, watermarkTextInput.value, boldFont);
                }

                updateProgress(75, 'Applying encryption and finalizing...');

                // --- Apply Encryption (if password provided) ---
                const encryptionPassword = encryptionPasswordInput.value;
                let pdfBytes;
                if (encryptionPassword) {
                    pdfBytes = await pdfDoc.save({
                        encryption: {
                            userPassword: encryptionPassword,
                            ownerPassword: encryptionPassword,
                        },
                    });
                } else {
                    pdfBytes = await pdfDoc.save();
                }

                updateProgress(100, 'PDF generated!');

                // Create a Blob and a download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                downloadPdfLink.href = url;
                downloadPdfLink.download = `${pdfTitleInput.value.replace(/[^a-zA-Z0-9]/g, '_') || 'document'}.pdf`; // Sanitize filename
                showElement(downloadSection);

            } catch (error) {
                displayError(`Failed to generate PDF: ${error.message}. Please check your inputs and try again.`);
                console.error('PDF generation error:', error);
            } finally {
                hideLoading(); // Hide loading indicator
            }
        }

        /**
         * Draws the header and footer on a given PDF page.
         * @param {PDFPage} page The PDF page object.
         * @param {number} pageNumber The current page number (1-indexed).
         * @param {number} totalPages The total number of pages.
         * @param {PDFFont} font The font to use for header/footer.
         * @param {number} margin The page margin.
         * @param {number} contentWidth The width available for content.
         */
        async function drawHeaderFooter(page, pageNumber, totalPages, font, margin, contentWidth) {
            const headerText = headerTextInput.value.trim();
            const footerText = footerTextInput.value.trim();
            const fontSize = 10;
            const textColor = rgb(0.5, 0.5, 0.5); // Gray color for header/footer

            // Header
            if (headerText) {
                const headerY = page.getHeight() - margin + 20; // Position above top margin
                page.drawText(headerText, {
                    x: margin,
                    y: headerY,
                    font,
                    size: fontSize,
                    color: textColor,
                });
            }

            // Footer
            if (footerText) {
                let formattedFooterText = footerText
                    .replace(/\[pageNumber\]/g, pageNumber)
                    .replace(/\[pageCount\]/g, totalPages);

                const footerY = margin - 30; // Position below bottom margin
                const footerWidth = font.widthOfTextAtSize(formattedFooterText, fontSize);
                const footerX = page.getWidth() / 2 - footerWidth / 2; // Center footer

                page.drawText(formattedFooterText, {
                    x: footerX,
                    y: footerY,
                    font,
                    size: fontSize,
                    color: textColor,
                });
            }
        }

        /**
         * Draws a text watermark on a given PDF page.
         * @param {PDFPage} page The PDF page object.
         * @param {string} watermarkText The text for the watermark.
         * @param {PDFFont} font The font to use for the watermark.
         */
        async function drawWatermark(page, watermarkText, font) {
            if (!watermarkText.trim()) return;

            const { width, height } = page.getSize();
            const fontSize = 72; // Large font size for watermark
            const opacity = 0.1; // Subtle opacity

            // Calculate text dimensions
            const textWidth = font.widthOfTextAtSize(watermarkText, fontSize);
            const textHeight = font.heightAtSize(fontSize);

            // Calculate position for diagonal placement
            // This places the text roughly in the center, rotated
            const centerX = width / 2;
            const centerY = height / 2;

            page.drawText(watermarkText, {
                x: centerX - textWidth / 2, // Adjust X to center after rotation
                y: centerY - textHeight / 2, // Adjust Y to center after rotation
                font,
                size: fontSize,
                color: rgb(0.5, 0.5, 0.5), // Gray color for watermark
                opacity: opacity,
                rotate: PDFLib.degrees(-45), // Rotate by -45 degrees for diagonal effect
            });
        }

        /**
         * Draws a text overlay on a given PDF page.
         * @param {PDFPage} page The PDF page object.
         * @param {PDFFont} font The font to use for the overlay.
         */
        async function drawTextOverlay(page, font) {
            const overlayText = overlayTextInput.value.trim();
            if (!overlayText) return;

            const overlayFontSize = parseInt(overlayFontSizeInput.value) || 24;
            const overlayX = parseInt(overlayXPosInput.value) || 50;
            const overlayY = parseInt(overlayYPosInput.value) || 50;
            const overlayColor = hexToRgb(overlayColorInput.value || '#FFFFFF'); // Default white

            page.drawText(overlayText, {
                x: overlayX,
                y: overlayY,
                font,
                size: overlayFontSize,
                color: overlayColor,
            });
        }

        // --- Drag and Drop for Upload Area ---
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('drag-over');
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('drag-over');
        });

        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            handleFiles(files);
        });

        // Click to browse functionality
        dropArea.addEventListener('click', () => {
            fileUploadInput.click();
        });

        // File input change listener (for traditional browse)
        fileUploadInput.addEventListener('change', (event) => {
            handleFiles(event.target.files);
            event.target.value = ''; // Clear input to allow re-uploading same files
        });


        // --- Initial Setup ---
        window.onload = () => {
            hideLoading(); // Hide loading indicator initially
            hideElement(downloadSection); // Hide download section initially
            hideElement(uploadedFilesContainer); // Hide file list initially
            clearError(); // Clear any initial errors
        };
    </script>
</body>
</html>
