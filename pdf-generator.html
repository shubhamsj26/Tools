<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Creator Tool - Generate from Multiple Files, Images, Text (Unstyled)</title>
    <!-- Tailwind CSS CDN REMOVED: To restore styling, you would need to compile Tailwind CSS locally
         or write custom CSS rules to replace the utility classes used in the HTML. -->
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Basic styles for functionality, but visual design will be lost without Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background-color: #1a202c; /* A dark background for visibility */
            color: #e2e8f0; /* Light text color */
        }

        .main-container {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 1.5rem;
            max-width: 48rem; /* 4xl equivalent */
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 2.25rem; /* 4xl */
            font-weight: 800; /* extabold */
            text-align: center;
            margin-bottom: 1.5rem;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        p {
            text-align: center;
            color: #cbd5e0; /* gray-200 */
            margin-bottom: 2rem;
        }

        /* Loading Indicator */
        #loading-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            background-color: rgba(49, 130, 206, 0.8); /* blue-600 with opacity */
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            color: white;
            font-weight: 600;
        }
        #loading-indicator .spinner {
            animation: spin 1s linear infinite;
            margin-right: 0.75rem;
            height: 1.25rem;
            width: 1.25rem;
            color: white;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        #loading-indicator .progress-bar-container {
            width: 100%;
            background-color: #bfdbfe; /* blue-200 */
            border-radius: 9999px; /* full */
            height: 0.625rem; /* h-2.5 */
        }
        #loading-indicator #progress-bar {
            background-color: #2b6cb0; /* blue-800 */
            height: 0.625rem;
            border-radius: 9999px;
            transition: width 0.3s ease-in-out;
        }

        /* Error Message */
        #error-message-container {
            background-color: rgba(239, 68, 68, 0.2); /* red-500 with opacity */
            border: 1px solid #ef4444; /* red-400 */
            color: #fca5a5; /* red-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        /* File Upload Section */
        .file-upload-section label {
            display: block;
            font-size: 1.125rem; /* lg */
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.9);
        }
        .drag-area {
            border: 2px dashed rgba(255, 255, 255, 0.4);
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 0.5rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .drag-area:hover {
            border-color: #60a5fa; /* blue-400 */
        }
        .drag-area.drag-over {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: #60A5FA; /* blue-400 */
        }
        .drag-area i {
            font-size: 2.25rem; /* 3xl */
            margin-bottom: 0.5rem;
            color: #94a3b8; /* gray-400 */
        }
        .drag-area p {
            color: #cbd5e0; /* gray-300 */
            font-size: 1.125rem; /* lg */
            margin-bottom: 0.5rem;
        }
        .drag-area p span {
            color: #60a5fa; /* blue-400 */
            font-weight: 700;
            text-decoration: underline;
        }
        .drag-area .note {
            font-size: 0.875rem; /* sm */
            color: #a0aec0; /* gray-400 */
            margin-top: 0.5rem;
        }
        .drag-area .error-note {
            color: #f87171; /* red-300 */
            margin-top: 0.5rem;
        }

        /* Uploaded Files List */
        #uploaded-files-container h3 {
            font-size: 1.5rem; /* 2xl */
            font-weight: 700;
            margin-bottom: 1rem;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #uploaded-files-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .page-item {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            color: #e2e8f0; /* gray-200 */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .page-item:active {
            cursor: grabbing;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            transform: scale(1.02);
        }
        .page-item.dragging {
            opacity: 0.5;
            border: 2px dashed #60A5FA;
        }
        .page-item .handle {
            color: #a0aec0; /* gray-400 */
            margin-right: 0.75rem;
            cursor: grab;
        }
        .page-item img {
            width: 4rem; /* w-16 */
            height: 4rem; /* h-16 */
            object-fit: cover;
            border-radius: 0.375rem; /* rounded-md */
            margin-right: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .page-item i.fa-file-alt, .page-item i.fa-file {
            font-size: 2.5rem; /* 4xl */
            margin-right: 1rem;
        }
        .page-item i.fa-file-alt { color: #60a5fa; /* blue-300 */ }
        .page-item i.fa-file { color: #a0aec0; /* gray-300 */ }

        .page-item span {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 0.875rem; /* sm */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .page-item span {
                font-size: 1rem; /* base */
            }
        }
        .page-item .actions {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* space-x-2 */
            margin-left: 1rem;
        }
        .page-item button {
            padding: 0.5rem;
            border-radius: 9999px; /* full */
            color: white;
            font-size: 0.75rem; /* sm */
            transition: background-color 0.2s ease;
            outline: none;
        }
        .page-item button:focus-visible {
            outline: 2px solid;
            outline-offset: 2px;
            border-radius: 9999px;
        }
        .page-item .rotate-btn {
            background-color: #3b82f6; /* blue-500 */
        }
        .page-item .rotate-btn:hover {
            background-color: #2563eb; /* blue-600 */
        }
        .page-item .rotate-btn:focus-visible {
            outline-color: #60a5fa; /* blue-400 */
        }
        .page-item .remove-btn {
            background-color: #ef4444; /* red-500 */
        }
        .page-item .remove-btn:hover {
            background-color: #dc2626; /* red-600 */
        }
        .page-item .remove-btn:focus-visible {
            outline-color: #f87171; /* red-400 */
        }

        /* PDF Settings Section */
        .settings-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .settings-section h3 {
            font-size: 1.5rem; /* 2xl */
            font-weight: 700;
            margin-bottom: 1rem;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .settings-section h4 {
            font-size: 1.25rem; /* xl */
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #93c5fd; /* blue-300 */
        }
        .settings-section .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }
        @media (min-width: 768px) { /* md breakpoint */
            .settings-section .grid-cols-1.md\:grid-cols-2 {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
            .settings-section .md\:col-span-2 {
                grid-column: span 2 / span 2;
            }
        }
        .settings-section label {
            display: block;
            font-size: 0.875rem; /* sm */
            font-weight: 500;
            color: #cbd5e0; /* gray-300 */
            margin-bottom: 0.25rem;
        }
        .settings-section input[type="text"],
        .settings-section input[type="number"],
        .settings-section input[type="password"],
        .settings-section select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .settings-section input[type="text"]::placeholder,
        .settings-section input[type="number"]::placeholder,
        .settings-section input[type="password"]::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .settings-section input[type="text"]:focus,
        .settings-section input[type="number"]:focus,
        .settings-section input[type="password"]:focus,
        .settings-section select:focus {
            border-color: #60a5fa; /* blue-400 */
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5); /* ring-2 blue-400 */
        }
        .settings-section select {
            cursor: pointer;
        }
        .settings-section select option {
            background-color: #2d3748; /* gray-800 */
            color: white;
        }
        .settings-section input[type="color"] {
            width: 100%;
            height: 2.5rem; /* h-10 */
            padding: 0.25rem;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            outline: none;
            cursor: pointer;
        }
        .settings-section input[type="color"]:focus-visible {
            outline: 2px solid #60A5FA;
            outline-offset: 2px;
            border-radius: 0.5rem;
        }
        .settings-section .text-xs {
            font-size: 0.75rem;
            color: #a0aec0; /* gray-400 */
            margin-top: 0.25rem;
        }

        /* Generate PDF Button */
        .generate-button-container {
            margin-top: 2rem;
            text-align: center;
        }
        #generate-pdf-button {
            width: 100%;
            padding: 0.75rem 2rem;
            border-radius: 9999px; /* full */
            font-size: 1.125rem; /* lg */
            font-weight: 700;
            background-color: #10b981; /* green-500 */
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease, transform 0.3s ease;
            outline: none;
        }
        #generate-pdf-button:hover {
            background-color: #059669; /* green-600 */
            transform: scale(1.05);
        }
        #generate-pdf-button:focus-visible {
            outline: 2px solid #34d399; /* green-400 */
            outline-offset: 2px;
            border-radius: 9999px;
        }
        #generate-pdf-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        #generate-pdf-button i {
            margin-right: 0.5rem;
        }
        @media (min-width: 768px) { /* md breakpoint */
            #generate-pdf-button {
                width: auto;
            }
        }

        /* Download Section */
        #download-section {
            margin-top: 2rem;
            text-align: center;
        }
        #download-section h3 {
            font-size: 1.5rem; /* 2xl */
            font-weight: 700;
            margin-bottom: 1rem;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #download-pdf-link {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6; /* blue-500 */
            color: white;
            font-weight: 700;
            border-radius: 9999px; /* full */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease, transform 0.3s ease;
            outline: none;
        }
        #download-pdf-link:hover {
            background-color: #2563eb; /* blue-600 */
            transform: scale(1.05);
        }
        #download-pdf-link:focus-visible {
            outline: 2px solid #60a5fa; /* blue-400 */
            outline-offset: 2px;
            border-radius: 9999px;
        }
        #download-pdf-link i {
            margin-right: 0.5rem;
        }

        /* Hidden elements */
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-700 to-purple-900 text-gray-100 flex flex-col items-center p-4">

    <!-- Main Container -->
    <div class="main-container">
        <h1>
            Advanced PDF Creator
        </h1>
        <p>Generate PDFs from multiple images, text, and customize every detail.</p>

        <!-- Loading Indicator & Progress Bar -->
        <div id="loading-indicator" class="hidden">
            <div class="flex items-center mb-2">
                <svg class="spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="loading-text">Processing files...</span>
            </div>
            <div class="progress-bar-container">
                <div id="progress-bar" style="width: 0%"></div>
            </div>
        </div>

        <!-- Error Message Display -->
        <div id="error-message-container" class="hidden">
            <p class="font-semibold">Error:</p>
            <p id="error-message-text"></p>
        </div>

        <!-- File Upload Section -->
        <div class="mb-6 file-upload-section">
            <label for="file-upload">
                1. Upload Files (Max 50 files - JPG, PNG, GIF, TXT):
            </label>
            <div id="drop-area" class="drag-area">
                <input type="file" id="file-upload" multiple accept="image/png, image/jpeg, image/gif, text/plain" class="hidden">
                <p><i class="fas fa-cloud-upload-alt"></i></p>
                <p>Drag & Drop files here, or <span>Click to Browse</span></p>
                <p class="note">Supported: Images (JPG, PNG, GIF), Text (.TXT)</p>
                <p class="note error-note">Note: DOCX/PPTX/XLSX conversion is not supported client-side.</p>
            </div>
        </div>

        <!-- Uploaded Files List & Reordering -->
        <div id="uploaded-files-container" class="mt-6 mb-8 hidden">
            <h3>
                2. Arrange Pages & Edit
            </h3>
            <div id="uploaded-files-list">
                <!-- Uploaded files will be listed here -->
            </div>
        </div>

        <!-- PDF Settings Section -->
        <div class="settings-section">
            <h3>PDF Settings & Customization</h3>

            <!-- Page Size & Orientation -->
            <div class="mb-6">
                <h4>Page Layout</h4>
                <div class="grid grid-cols-1 md:grid-cols-2">
                    <div>
                        <label for="page-size">Page Size:</label>
                        <select id="page-size">
                            <option value="A4">A4 (210 x 297 mm)</option>
                            <option value="Letter">Letter (8.5 x 11 in)</option>
                            <option value="Legal">Legal (8.5 x 14 in)</option>
                        </select>
                    </div>
                    <div>
                        <label for="page-orientation">Orientation:</label>
                        <select id="page-orientation">
                            <option value="portrait">Portrait</option>
                            <option value="landscape">Landscape</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Text Overlay -->
            <div class="mb-6">
                <h4>Text Overlay (Per Page)</h4>
                <div class="grid grid-cols-1 md:grid-cols-2">
                    <div class="md:col-span-2">
                        <label for="overlay-text">Overlay Text:</label>
                        <input type="text" id="overlay-text" placeholder="Text to appear on each page">
                    </div>
                    <div>
                        <label for="overlay-font-size">Font Size:</label>
                        <input type="number" id="overlay-font-size" value="24" min="8" max="100">
                    </div>
                    <div>
                        <label for="overlay-x-pos">X Position (from left):</label>
                        <input type="number" id="overlay-x-pos" value="50">
                    </div>
                    <div>
                        <label for="overlay-y-pos">Y Position (from bottom):</label>
                        <input type="number" id="overlay-y-pos" value="50">
                    </div>
                    <div>
                        <label for="overlay-color">Text Color:</label>
                        <input type="color" id="overlay-color" value="#FFFFFF">
                    </div>
                </div>
            </div>

            <!-- Meta Tags -->
            <div class="mb-6">
                <h4>Meta Tags</h4>
                <div class="grid grid-cols-1 md:grid-cols-2">
                    <div>
                        <label for="pdf-title">Title:</label>
                        <input type="text" id="pdf-title" placeholder="Document Title">
                    </div>
                    <div>
                        <label for="pdf-author">Author:</label>
                        <input type="text" id="pdf-author" placeholder="Document Author">
                    </div>
                    <div class="md:col-span-2">
                        <label for="pdf-keywords">Keywords (comma-separated):</label>
                        <input type="text" id="pdf-keywords" placeholder="keywords, separated, by, comma">
                    </div>
                </div>
            </div>

            <!-- PDF Version & Encryption -->
            <div class="mb-6">
                <h4>Version & Security</h4>
                <div class="grid grid-cols-1 md:grid-cols-2">
                    <div>
                        <label for="pdf-version">PDF Version:</label>
                        <select id="pdf-version">
                            <option value="1.7">1.7 (Default)</option>
                            <option value="1.4">1.4</option>
                            <option value="1.5">1.5</option>
                            <option value="1.6">1.6</option>
                        </select>
                    </div>
                    <div>
                        <label for="encryption-password">Encryption Password (Optional):</label>
                        <input type="password" id="encryption-password" placeholder="Leave blank for no encryption">
                    </div>
                </div>
            </div>

            <!-- Customization: Watermark, Header, Footer -->
            <div>
                <h4>Page Customization</h4>
                <div class="mb-4">
                    <label for="watermark-text">Watermark Text (Optional):</label>
                    <input type="text" id="watermark-text" placeholder="e.g., DRAFT, CONFIDENTIAL">
                </div>
                <div class="mb-4">
                    <label for="header-text">Header Text (Optional):</label>
                    <input type="text" id="header-text" placeholder="e.g., Company Name, Document Title">
                </div>
                <div>
                    <label for="footer-text">Footer Text (Optional):</label>
                    <input type="text" id="footer-text" placeholder="e.g., Page [pageNumber] of [pageCount]">
                    <p class="text-xs">Use `[pageNumber]` and `[pageCount]` for dynamic page numbering.</p>
                </div>
            </div>
        </div>

        <!-- Generate PDF Button -->
        <div class="mt-8 text-center generate-button-container">
            <button id="generate-pdf-button" disabled>
                <i class="fas fa-file-export mr-2"></i> Generate PDF
            </button>
        </div>

        <!-- Download Link -->
        <div id="download-section" class="mt-8 text-center hidden">
            <h3>Download Your PDF</h3>
            <a id="download-pdf-link" href="#" download="generated-document.pdf">
                <i class="fas fa-download mr-2"></i> Download PDF
            </a>
        </div>

    </div>

    <!-- Hidden Canvas for Image Processing (for rotation) -->
    <canvas id="hidden-canvas" class="hidden"></canvas>

    <!-- pdf-lib CDN -->
    <script src="https://unpkg.com/@pdf-lib/fontkit@1.0.1/dist/fontkit.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

    <script>
        // Destructure necessary modules from pdf-lib
        const { PDFDocument, rgb, StandardFonts, PDFName, PDFString, PDFArray, PDFDict, PageSizes } = PDFLib;

        // --- DOM Element References ---
        const loadingIndicator = document.getElementById('loading-indicator');
        const loadingText = document.getElementById('loading-text');
        const progressBar = document.getElementById('progress-bar');
        const errorMessageContainer = document.getElementById('error-message-container');
        const errorMessageText = document.getElementById('error-message-text');

        const dropArea = document.getElementById('drop-area');
        const fileUploadInput = document.getElementById('file-upload');
        const uploadedFilesContainer = document.getElementById('uploaded-files-container');
        const uploadedFilesList = document.getElementById('uploaded-files-list');

        const pageSizeSelect = document.getElementById('page-size');
        const pageOrientationSelect = document.getElementById('page-orientation');

        const overlayTextInput = document.getElementById('overlay-text');
        const overlayFontSizeInput = document.getElementById('overlay-font-size');
        const overlayXPosInput = document.getElementById('overlay-x-pos');
        const overlayYPosInput = document.getElementById('overlay-y-pos');
        const overlayColorInput = document.getElementById('overlay-color');

        const pdfTitleInput = document.getElementById('pdf-title');
        const pdfAuthorInput = document.getElementById('pdf-author');
        const pdfKeywordsInput = document.getElementById('pdf-keywords');
        const pdfVersionSelect = document.getElementById('pdf-version');
        const encryptionPasswordInput = document.getElementById('encryption-password');

        const watermarkTextInput = document.getElementById('watermark-text');
        const headerTextInput = document.getElementById('header-text');
        const footerTextInput = document.getElementById('footer-text');

        const generatePdfButton = document.getElementById('generate-pdf-button');
        const downloadSection = document.getElementById('download-section');
        const downloadPdfLink = document.getElementById('download-pdf-link');

        const hiddenCanvas = document.getElementById('hidden-canvas');
        const hiddenCtx = hiddenCanvas.getContext('2d');

        // --- Global State Variables ---
        // Array to store uploaded files, their data, and properties
        let uploadedFiles = []; // { id: string, file: File, dataUrl: string, type: string, rotation: number, element: HTMLElement }
        const MAX_FILES = 50;
        let dragSrcEl = null; // For drag-and-drop reordering

        // --- Utility Functions ---

        /**
         * Displays a message in the error container.
         * @param {string} message The error message to display.
         */
        function displayError(message) {
            errorMessageText.textContent = message;
            errorMessageContainer.classList.remove('hidden');
        }

        /**
         * Clears any displayed error messages.
         */
        function clearError() {
            errorMessageText.textContent = '';
            errorMessageContainer.classList.add('hidden');
        }

        /**
         * Shows the loading indicator and disables the generate button.
         * @param {string} text The text to display in the loading indicator.
         */
        function showLoading(text = 'Processing files...') {
            loadingText.textContent = text;
            progressBar.style.width = '0%';
            loadingIndicator.classList.remove('hidden');
            generatePdfButton.disabled = true;
            generatePdfButton.classList.add('opacity-50', 'cursor-not-allowed');
            downloadSection.classList.add('hidden'); // Hide download link during generation
            clearError(); // Clear any previous errors
        }

        /**
         * Hides the loading indicator and enables the generate button.
         */
        function hideLoading() {
            loadingIndicator.classList.add('hidden');
            generatePdfButton.disabled = uploadedFiles.length === 0; // Enable only if files are present
            generatePdfButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        /**
         * Updates the progress bar.
         * @param {number} percentage The progress percentage (0-100).
         * @param {string} text Optional text to update the loading message.
         */
        function updateProgress(percentage, text = loadingText.textContent) {
            progressBar.style.width = `${percentage}%`;
            loadingText.textContent = text;
        }

        /**
         * Hides an HTML element by adding the 'hidden' class.
         * @param {HTMLElement} element The element to hide.
         */
        function hideElement(element) {
            element.classList.add('hidden');
        }

        /**
         * Shows an HTML element by removing the 'hidden' class.
         * @param {HTMLElement} element The element to show.
         */
        function showElement(element) {
            element.classList.remove('hidden');
        }

        /**
         * Converts a color hex string (e.g., "#RRGGBB") to an rgb object for pdf-lib.
         * @param {string} hex The hex color string.
         * @returns {object} An rgb object { red, green, blue }.
         */
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return rgb(r, g, b);
        }

        // --- File Handling and UI Management ---

        /**
         * Processes uploaded files and adds them to the list.
         * @param {FileList} files The FileList object from an input or drop event.
         */
        async function handleFiles(files) {
            clearError();
            hideElement(downloadSection);

            if (uploadedFiles.length + files.length > MAX_FILES) {
                displayError(`You can upload a maximum of ${MAX_FILES} files. Please remove some or upload fewer files.`);
                return;
            }

            for (let i = 0; i < files.length; i++) {
                const file = files[i];

                // Skip unsupported file types
                if (!['image/png', 'image/jpeg', 'image/gif', 'text/plain'].includes(file.type)) {
                    displayError(`Unsupported file type: ${file.name}. Only JPG, PNG, GIF, and TXT are supported.`);
                    continue;
                }

                // Check for duplicate files (simple check by name and size)
                if (uploadedFiles.some(f => f.file.name === file.name && f.file.size === file.size)) {
                    console.warn(`Skipping duplicate file: ${file.name}`);
                    continue;
                }

                showLoading(`Reading file ${i + 1} of ${files.length}...`);
                updateProgress((i / files.length) * 100);

                try {
                    const dataUrl = await readFileAsDataURL(file);
                    const id = `file-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

                    const fileEntry = {
                        id: id,
                        file: file,
                        dataUrl: dataUrl,
                        type: file.type,
                        rotation: 0, // Default rotation
                        element: null // Will store the DOM element
                    };
                    uploadedFiles.push(fileEntry);
                    addFileToList(fileEntry);

                } catch (error) {
                    displayError(`Failed to read file ${file.name}: ${error.message}`);
                    console.error(`File read error for ${file.name}:`, error);
                }
            }
            updateProgress(100, 'All files read.');
            hideLoading();
            if (uploadedFiles.length > 0) {
                showElement(uploadedFilesContainer);
            }
        }

        /**
         * Reads a File object as a Data URL.
         * @param {File} file The File object to read.
         * @returns {Promise<string>} A promise that resolves with the Data URL.
         */
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsDataURL(file);
            });
        }

        /**
         * Adds a file entry to the uploaded files list in the UI.
         * @param {object} fileEntry The file entry object.
         */
        function addFileToList(fileEntry) {
            const itemDiv = document.createElement('div');
            itemDiv.id = fileEntry.id;
            itemDiv.draggable = true;
            itemDiv.classList.add('page-item'); /* Removed Tailwind classes */

            let previewContent;
            if (fileEntry.type.startsWith('image/')) {
                previewContent = `<img src="${fileEntry.dataUrl}" alt="Preview of ${fileEntry.file.name}" style="transform: rotate(${fileEntry.rotation}deg);">`;
            } else if (fileEntry.type === 'text/plain') {
                previewContent = `<i class="fas fa-file-alt"></i>`;
            } else {
                previewContent = `<i class="fas fa-file"></i>`;
            }

            itemDiv.innerHTML = `
                <div class="flex-items-center flex-grow">
                    <i class="fas fa-grip-vertical handle"></i>
                    ${previewContent}
                    <span>${fileEntry.file.name}</span>
                </div>
                <div class="actions">
                    ${fileEntry.type.startsWith('image/') ? `
                    <button class="rotate-btn" title="Rotate Image">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    ` : ''}
                    <button class="remove-btn" title="Remove File">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            `;

            fileEntry.element = itemDiv; // Store reference to the DOM element
            uploadedFilesList.appendChild(itemDiv);

            // Add event listeners for buttons
            const removeBtn = itemDiv.querySelector('.remove-btn');
            if (removeBtn) {
                removeBtn.addEventListener('click', () => removeFile(fileEntry.id));
            }
            const rotateBtn = itemDiv.querySelector('.rotate-btn');
            if (rotateBtn) {
                rotateBtn.addEventListener('click', () => rotateImage(fileEntry.id));
            }

            // Add drag and drop listeners
            itemDiv.addEventListener('dragstart', handleDragStart);
            itemDiv.addEventListener('dragover', handleDragOver);
            itemDiv.addEventListener('dragleave', handleDragLeave);
            itemDiv.addEventListener('drop', handleDrop);
            itemDiv.addEventListener('dragend', handleDragEnd);

            generatePdfButton.disabled = false; // Enable generate button
        }

        /**
         * Removes a file from the uploaded list and UI.
         * @param {string} id The ID of the file entry to remove.
         */
        function removeFile(id) {
            uploadedFiles = uploadedFiles.filter(entry => entry.id !== id);
            const itemToRemove = document.getElementById(id);
            if (itemToRemove) {
                itemToRemove.remove();
            }
            if (uploadedFiles.length === 0) {
                hideElement(uploadedFilesContainer);
                generatePdfButton.disabled = true; // Disable if no files
            }
            hideElement(downloadSection); // Hide download link on file removal
            clearError();
        }

        /**
         * Rotates an image file entry by 90 degrees clockwise.
         * Updates the rotation state and preview.
         * @param {string} id The ID of the image file entry to rotate.
         */
        async function rotateImage(id) {
            const fileEntry = uploadedFiles.find(entry => entry.id === id);
            if (!fileEntry || !fileEntry.type.startsWith('image/')) return;

            fileEntry.rotation = (fileEntry.rotation + 90) % 360; // Rotate by 90 degrees

            // Update the preview image rotation
            const imgElement = fileEntry.element.querySelector('img');
            if (imgElement) {
                imgElement.style.transform = `rotate(${fileEntry.rotation}deg)`;
            }
            hideElement(downloadSection); // Hide download link on edit
            clearError();
        }

        // --- Drag and Drop Reordering Logic ---
        function handleDragStart(e) {
            dragSrcEl = this; // 'this' refers to the element being dragged
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.id); // Set data to transfer (element ID)
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow drop
            e.dataTransfer.dropEffect = 'move';
            if (this !== dragSrcEl && this.classList.contains('page-item')) {
                // Add a visual indicator for where the item will be dropped
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave() {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');

            if (dragSrcEl !== this) {
                const draggedId = e.dataTransfer.getData('text/plain');
                const draggedElement = document.getElementById(draggedId);
                const dropTargetElement = this;

                // Find indices in the uploadedFiles array
                const draggedIndex = uploadedFiles.findIndex(f => f.id === draggedId);
                const dropTargetIndex = uploadedFiles.findIndex(f => f.id === dropTargetElement.id);

                if (draggedIndex > -1 && dropTargetIndex > -1) {
                    // Reorder the array
                    const [removed] = uploadedFiles.splice(draggedIndex, 1);
                    uploadedFiles.splice(dropTargetIndex, 0, removed);

                    // Reorder DOM elements
                    if (draggedIndex < dropTargetIndex) {
                        dropTargetElement.parentNode.insertBefore(draggedElement, dropTargetElement.nextSibling);
                    } else {
                        dropTargetElement.parentNode.insertBefore(draggedElement, dropTargetElement);
                    }
                }
            }
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            // Remove drag-over class from all elements
            document.querySelectorAll('.page-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            dragSrcEl = null;
        }

        // --- Main PDF Generation Function ---

        /**
         * Generates the PDF document based on user inputs and settings.
         */
        async function generatePdf() {
            showLoading('Starting PDF generation...');

            try {
                // Determine page size and orientation
                const pageSize = PageSizes[pageSizeSelect.value];
                let pageWidth = pageSize[0];
                let pageHeight = pageSize[1];

                if (pageOrientationSelect.value === 'landscape') {
                    [pageWidth, pageHeight] = [pageHeight, pageWidth]; // Swap width and height for landscape
                }

                // Create a new PDF document
                const pdfDoc = await PDFDocument.create();
                pdfDoc.registerFontkit(fontkit);

                // Set PDF Meta Tags
                pdfDoc.setTitle(pdfTitleInput.value || 'Generated Document');
                pdfDoc.setAuthor(pdfAuthorInput.value || 'PDF Creator Tool');
                pdfDoc.setKeywords((pdfKeywordsInput.value || 'pdf, generator, tool, online').split(',').map(k => k.trim()));
                pdfDoc.setProducer('Online PDF Creator Tool');
                pdfDoc.setCreator('Online PDF Creator Tool');

                // Set PDF Version
                const pdfVersion = parseFloat(pdfVersionSelect.value);
                pdfDoc.setVersion(pdfVersion);

                // Embed standard fonts
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
                const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
                const italicFont = await pdfDoc.embedFont(StandardFonts.HelveticaOblique);

                const pageMargin = 50; // Margin from edges

                // Iterate through uploaded files in their current order
                for (let i = 0; i < uploadedFiles.length; i++) {
                    const fileEntry = uploadedFiles[i];
                    updateProgress(((i / uploadedFiles.length) * 100) * 0.5, `Adding page ${i + 1} of ${uploadedFiles.length}...`); // 50% for content adding

                    const page = pdfDoc.addPage([pageWidth, pageHeight]);
                    const contentWidth = page.getWidth() - 2 * pageMargin;
                    const contentHeight = page.getHeight() - 2 * pageMargin;

                    // --- Add Content Based on File Type ---
                    if (fileEntry.type.startsWith('image/')) {
                        let image;
                        let imageBytes;

                        // Re-draw image on a hidden canvas to apply rotation before embedding
                        const img = new Image();
                        img.src = fileEntry.dataUrl;
                        await new Promise(resolve => img.onload = resolve);

                        hiddenCanvas.width = img.width;
                        hiddenCanvas.height = img.height;
                        hiddenCtx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                        // Apply rotation
                        if (fileEntry.rotation !== 0) {
                            hiddenCtx.save();
                            hiddenCtx.translate(hiddenCanvas.width / 2, hiddenCanvas.height / 2);
                            hiddenCtx.rotate(fileEntry.rotation * Math.PI / 180);
                            hiddenCtx.drawImage(img, -img.width / 2, -img.height / 2);
                            hiddenCtx.restore();
                        } else {
                            hiddenCtx.drawImage(img, 0, 0);
                        }

                        // Get image data from canvas
                        const processedDataUrl = hiddenCanvas.toDataURL(fileEntry.type === 'image/gif' ? 'image/png' : fileEntry.type); // Convert GIF to PNG for static embed
                        imageBytes = await fetch(processedDataUrl).then(res => res.arrayBuffer());

                        // Embed image based on type
                        if (fileEntry.type === 'image/png' || fileEntry.type === 'image/gif') {
                            image = await pdfDoc.embedPng(imageBytes);
                        } else if (fileEntry.type === 'image/jpeg') {
                            image = await pdfDoc.embedJpg(imageBytes);
                        }

                        // Scale image to fit page, maintaining aspect ratio
                        const imageRatio = image.width / image.height;
                        let finalImageWidth = contentWidth;
                        let finalImageHeight = contentWidth / imageRatio;

                        if (finalImageHeight > contentHeight) {
                            finalImageHeight = contentHeight;
                            finalImageWidth = contentHeight * imageRatio;
                        }

                        // Center image on the page
                        const x = pageMargin + (contentWidth - finalImageWidth) / 2;
                        const y = pageMargin + (contentHeight - finalImageHeight) / 2;

                        page.drawImage(image, {
                            x: x,
                            y: y,
                            width: finalImageWidth,
                            height: finalImageHeight,
                        });

                    } else if (fileEntry.type === 'text/plain') {
                        const textContent = await fileEntry.file.text(); // Read text file content
                        const fontSize = 12;
                        const lineHeight = fontSize * 1.5;
                        const textColor = rgb(0.9, 0.9, 0.9); // Light gray for text

                        const words = textContent.split(' ');
                        let currentLine = '';
                        let yPos = page.getHeight() - pageMargin; // Start from top margin

                        for (let j = 0; j < words.length; j++) {
                            const word = words[j];
                            const testLine = currentLine === '' ? word : `${currentLine} ${word}`;
                            const textWidth = font.widthOfTextAtSize(testLine, fontSize);

                            if (textWidth < contentWidth) {
                                currentLine = testLine;
                            } else {
                                if (yPos < pageMargin + lineHeight) { // Check if new page is needed
                                    page.drawText(currentLine, { x: pageMargin, y: yPos, font, size: fontSize, color: textColor });
                                    page = pdfDoc.addPage([pageWidth, pageHeight]); // Add new page
                                    yPos = page.getHeight() - pageMargin;
                                    // Redraw header/footer, watermark, and text overlay on new page
                                    await drawHeaderFooter(page, pdfDoc.getPages().length, uploadedFiles.length, boldFont, pageMargin, contentWidth);
                                    await drawWatermark(page, watermarkTextInput.value, boldFont);
                                    await drawTextOverlay(page, font);
                                }
                                page.drawText(currentLine, { x: pageMargin, y: yPos, font, size: fontSize, color: textColor });
                                yPos -= lineHeight;
                                currentLine = word;
                            }
                        }
                        if (currentLine !== '') { // Draw any remaining text
                            if (yPos < pageMargin + lineHeight) {
                                page = pdfDoc.addPage([pageWidth, pageHeight]);
                                yPos = page.getHeight() - pageMargin;
                                await drawHeaderFooter(page, pdfDoc.getPages().length, uploadedFiles.length, boldFont, pageMargin, contentWidth);
                                await drawWatermark(page, watermarkTextInput.value, boldFont);
                                await drawTextOverlay(page, font);
                            }
                            page.drawText(currentLine, { x: pageMargin, y: yPos, font, size: fontSize, color: textColor });
                        }
                    }
                    // Add text overlay, header, footer, watermark after content is drawn for each page
                    // This ensures they are on top of content and on every page.
                    await drawTextOverlay(page, font);
                    await drawHeaderFooter(page, i + 1, uploadedFiles.length, boldFont, pageMargin, contentWidth);
                    await drawWatermark(page, watermarkTextInput.value, boldFont);
                }

                updateProgress(75, 'Applying encryption and finalizing...');

                // --- Apply Encryption (if password provided) ---
                const encryptionPassword = encryptionPasswordInput.value;
                let pdfBytes;
                if (encryptionPassword) {
                    pdfBytes = await pdfDoc.save({
                        encryption: {
                            userPassword: encryptionPassword,
                            ownerPassword: encryptionPassword,
                        },
                    });
                } else {
                    pdfBytes = await pdfDoc.save();
                }

                updateProgress(100, 'PDF generated!');

                // Create a Blob and a download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                downloadPdfLink.href = url;
                downloadPdfLink.download = `${pdfTitleInput.value.replace(/[^a-zA-Z0-9]/g, '_') || 'document'}.pdf`; // Sanitize filename
                showElement(downloadSection);

            } catch (error) {
                displayError(`Failed to generate PDF: ${error.message}. Please check your inputs and try again.`);
                console.error('PDF generation error:', error);
            } finally {
                hideLoading(); // Hide loading indicator
            }
        }

        /**
         * Draws the header and footer on a given PDF page.
         * @param {PDFPage} page The PDF page object.
         * @param {number} pageNumber The current page number (1-indexed).
         * @param {number} totalPages The total number of pages.
         * @param {PDFFont} font The font to use for header/footer.
         * @param {number} margin The page margin.
         * @param {number} contentWidth The width available for content.
         */
        async function drawHeaderFooter(page, pageNumber, totalPages, font, margin, contentWidth) {
            const headerText = headerTextInput.value.trim();
            const footerText = footerTextInput.value.trim();
            const fontSize = 10;
            const textColor = rgb(0.5, 0.5, 0.5); // Gray color for header/footer

            // Header
            if (headerText) {
                const headerY = page.getHeight() - margin + 20; // Position above top margin
                page.drawText(headerText, {
                    x: margin,
                    y: headerY,
                    font,
                    size: fontSize,
                    color: textColor,
                });
            }

            // Footer
            if (footerText) {
                let formattedFooterText = footerText
                    .replace(/\[pageNumber\]/g, pageNumber)
                    .replace(/\[pageCount\]/g, totalPages);

                const footerY = margin - 30; // Position below bottom margin
                const footerWidth = font.widthOfTextAtSize(formattedFooterText, fontSize);
                const footerX = page.getWidth() / 2 - footerWidth / 2; // Center footer

                page.drawText(formattedFooterText, {
                    x: footerX,
                    y: footerY,
                    font,
                    size: fontSize,
                    color: textColor,
                });
            }
        }

        /**
         * Draws a text watermark on a given PDF page.
         * @param {PDFPage} page The PDF page object.
         * @param {string} watermarkText The text for the watermark.
         * @param {PDFFont} font The font to use for the watermark.
         */
        async function drawWatermark(page, watermarkText, font) {
            if (!watermarkText.trim()) return;

            const { width, height } = page.getSize();
            const fontSize = 72; // Large font size for watermark
            const opacity = 0.1; // Subtle opacity

            // Calculate text dimensions
            const textWidth = font.widthOfTextAtSize(watermarkText, fontSize);
            const textHeight = font.heightAtSize(fontSize);

            // Calculate position for diagonal placement
            // This places the text roughly in the center, rotated
            const centerX = width / 2;
            const centerY = height / 2;

            page.drawText(watermarkText, {
                x: centerX - textWidth / 2, // Adjust X to center after rotation
                y: centerY - textHeight / 2, // Adjust Y to center after rotation
                font,
                size: fontSize,
                color: rgb(0.5, 0.5, 0.5), // Gray color for watermark
                opacity: opacity,
                rotate: PDFLib.degrees(-45), // Rotate by -45 degrees for diagonal effect
            });
        }

        /**
         * Draws a text overlay on a given PDF page.
         * @param {PDFPage} page The PDF page object.
         * @param {PDFFont} font The font to use for the overlay.
         */
        async function drawTextOverlay(page, font) {
            const overlayText = overlayTextInput.value.trim();
            if (!overlayText) return;

            const overlayFontSize = parseInt(overlayFontSizeInput.value) || 24;
            const overlayX = parseInt(overlayXPosInput.value) || 50;
            const overlayY = parseInt(overlayYPosInput.value) || 50;
            const overlayColor = hexToRgb(overlayColorInput.value || '#FFFFFF'); // Default white

            page.drawText(overlayText, {
                x: overlayX,
                y: overlayY,
                font,
                size: overlayFontSize,
                color: overlayColor,
            });
        }

        // --- Drag and Drop for Upload Area ---
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('drag-over');
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('drag-over');
        });

        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            handleFiles(files);
        });

        // Click to browse functionality
        dropArea.addEventListener('click', () => {
            fileUploadInput.click();
        });

        // File input change listener (for traditional browse)
        fileUploadInput.addEventListener('change', (event) => {
            handleFiles(event.target.files);
            event.target.value = ''; // Clear input to allow re-uploading same files
        });


        // --- Initial Setup ---
        window.onload = () => {
            hideLoading(); // Hide loading indicator initially
            hideElement(downloadSection); // Hide download section initially
            hideElement(uploadedFilesContainer); // Hide file list initially
            clearError(); // Clear any initial errors
        };
    </script>
</body>
</html>
